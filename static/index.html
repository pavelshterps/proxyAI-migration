<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>proxyAI Demo UI</title>
  <style>
    body { font-family: sans-serif; margin:2rem }
    .segment { border-bottom:1px solid #ccc; padding:.5rem 0 }
    .time { color:#666; margin-right:.5rem }
    input { width:120px; margin:0 .5rem }
  </style>
</head>
<body>
  <h1>proxyAI Demo UI</h1>
  <label>API-Key: <input id="apiKey" type="text"></label>
  <label>File: <input id="audioFile" type="file" accept="audio/*,video/*"></label>
  <button id="uploadBtn">Загрузить и начать</button>
  <div id="status"></div>
  <div id="timings"></div>
  <audio id="audio" controls style="width:100%"></audio>
  <div id="transcriptContainer"></div>
  <button id="saveLabelsBtn" disabled>Сохранить метки спикеров</button>

  <script>
  (function(){
    const apiKey    = document.getElementById('apiKey');
    const fileInput = document.getElementById('audioFile');
    const uploadBtn = document.getElementById('uploadBtn');
    const status    = document.getElementById('status');
    const timings   = document.getElementById('timings');
    const audio     = document.getElementById('audio');
    const container = document.getElementById('transcriptContainer');
    const saveBtn   = document.getElementById('saveLabelsBtn');

    let uploadId, mapping = {};

    // форматирование времени
    function formatTime(ms){
      const s = Math.floor(ms/1000),
            m = String(Math.floor(s/60)).padStart(2,'0'),
            sec = String(s%60).padStart(2,'0');
      return `${m}:${sec}`;
    }

    // отрисовка списка сегментов
    function render(list){
      container.innerHTML = '';
      const frag = document.createDocumentFragment();
      mapping = {};  // сбросим старые метки

      list.forEach(seg=>{
        const orig = seg.speaker || '';
        mapping[orig] = orig;   // по умолчанию имя=ключ

        const div = document.createElement('div');
        div.className = 'segment';

        const t = document.createElement('span');
        t.className = 'time';
        t.textContent = formatTime(seg.start*1000);

        const btn = document.createElement('button');
        btn.textContent = '▶️';
        btn.onclick = ()=>{
          audio.currentTime = seg.start;
          audio.play();
          setTimeout(()=>audio.pause(), (seg.end-seg.start)*1000);
        };

        const inp = document.createElement('input');
        inp.value = orig;
        inp.dataset.orig = orig;
        inp.oninput = ()=>{
          const o = inp.dataset.orig, n = inp.value.trim();
          if(!n || n.length>50){
            inp.value = mapping[o];
            return;
          }
          mapping[o] = n;
          // обновляем только текстовые поля с тем же orig
          container.querySelectorAll('input').forEach(i=>{
            if(i.dataset.orig === o) i.value = n;
          });
          saveBtn.disabled = false;
        };

        const txt = document.createElement('span');
        txt.textContent = seg.text;

        div.append(t, btn, inp, txt);
        frag.append(div);
      });

      container.append(frag);
      saveBtn.disabled = true; // кнопка заблокирована до изменений
    }

    // сохраняем новые метки на сервере
    saveBtn.onclick = async ()=>{
      const payload = {};
      for(const [o,n] of Object.entries(mapping)){
        if(o!==n) payload[o] = n;
      }
      if(Object.keys(payload).length===0) return alert('Нет изменений');
      try {
        const res = await fetch(`/labels/${uploadId}`, {
          method:'POST',
          headers:{
            'Content-Type':'application/json',
            'X-API-Key':apiKey.value.trim()
          },
          body:JSON.stringify(payload)
        });
        if(!res.ok) throw new Error(res.status);
        const {results} = await res.json();
        render(results);
        status.textContent = 'Метки сохранены';
      } catch(e){
        alert('Ошибка сохранения: '+e);
      }
    };

    // основная логика загрузки
    uploadBtn.onclick = async ()=>{
      if(!apiKey.value.trim()) return alert('Введите API-Key');
      const f = fileInput.files[0];
      if(!f) return alert('Выберите файл');

      status.textContent = 'Загружаем...';
      const form = new FormData(); form.append('file', f);
      const resp = await fetch('/upload/', {
        method:'POST',
        headers:{ 'X-API-Key':apiKey.value.trim() },
        body:form
      });
      if(!resp.ok) return alert('Upload error '+resp.status);
      uploadId = (await resp.json()).upload_id;
      audio.src = URL.createObjectURL(f);
      status.textContent = 'Ожидаем прогресса...';

      // SSE
      const es = new EventSource(`/events/${uploadId}?api_key=${encodeURIComponent(apiKey.value.trim())}`);
      es.onmessage = e=>{
        let d = e.data.trim();
        if(!d||d===':') return;
        if(d.startsWith('data:')) d=d.replace(/^data:\s*/,'');
        const st = JSON.parse(d);
        status.textContent = `Статус: ${st.status}`;
        if(st.preview){
          render(st.preview.timestamps);
        }
        if(st.status==='diarization_done'){
          es.close();
          loadResults();
        }
      };
    };

    // загрузка окончательного результата
    async function loadResults(){
      status.textContent = 'Получаем результат...';
      const resp = await fetch(`/results/${uploadId}`, {
        headers:{ 'X-API-Key':apiKey.value.trim() }
      });
      if(!resp.ok) return alert('Results error '+resp.status);
      const {results} = await resp.json();
      render(results);
      status.textContent = 'Готово';
    }
  })();
  </script>
</body>
</html>